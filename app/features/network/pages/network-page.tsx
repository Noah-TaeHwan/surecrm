import type { Route } from './+types/network-page';
import { MainLayout } from '~/common/layouts/main-layout';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '~/common/components/ui/card';
import NetworkControls from '../components/NetworkControls';
import NetworkSidebar from '../components/NetworkSidebar';
import NetworkDetailPanel from '../components/NetworkDetailPanel';
import {
  useRef,
  useState,
  useCallback,
  useEffect,
  useMemo,
  Suspense,
  Component,
} from 'react';
import type { ErrorInfo, ReactNode } from 'react';
import type {
  NetworkNode,
  NetworkLink,
  NetworkData,
  NetworkFilters,
} from '../types';

// Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìï®ÏàòÎì§ import
import { getNetworkData, searchNetwork } from '../lib/network-data';
import { requireAuth } from '~/lib/auth/middleware';

export async function loader({ request }: Route.LoaderArgs) {
  try {
    // Ïù∏Ï¶ù ÌôïÏù∏
    const user = await requireAuth(request);

    // Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    const networkData = await getNetworkData(user.id);

    return {
      nodes: networkData.nodes,
      edges: networkData.edges,
      stats: networkData.stats,
      agentId: user.id,
    };
  } catch (error) {
    console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);

    // ÏóêÎü¨ Ïãú Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
    return {
      nodes: [],
      edges: [],
      stats: {
        totalNodes: 0,
        totalEdges: 0,
        maxDepth: 0,
        avgReferralsPerNode: 0,
        topReferrers: [],
        networkGrowth: [],
      },
      agentId: 'fallback-agent-id',
    };
  }
}

export async function action({ request }: Route.ActionArgs) {
  try {
    const user = await requireAuth(request);
    const formData = await request.formData();
    const intent = formData.get('intent');

    if (intent === 'search') {
      const query = formData.get('query') as string;
      const results = await searchNetwork(user.id, query);
      return { searchResults: results };
    }

    return { success: false, message: 'Ïïå Ïàò ÏóÜÎäî ÏöîÏ≤≠ÏûÖÎãàÎã§.' };
  } catch (error) {
    console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïï°ÏÖò Ïò§Î•ò:', error);
    return { success: false, message: 'ÏöîÏ≤≠ Ï≤òÎ¶¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' };
  }
}

export function meta({ data, params }: Route.MetaArgs) {
  return [
    { title: 'ÏÜåÍ∞ú ÎÑ§Ìä∏ÏõåÌÅ¨ - SureCRM' },
    {
      name: 'description',
      content: 'Í≥†Í∞ù Í∞Ñ ÏÜåÍ∞ú Í¥ÄÍ≥ÑÎ•º ÏãúÍ∞ÅÌôîÌïòÏó¨ ÎÑ§Ìä∏ÏõåÌÅ¨ Ìö®Í≥ºÎ•º Í∑πÎåÄÌôîÌïòÏÑ∏Ïöî.',
    },
  ];
}

// Error Boundary Ïª¥Ìè¨ÎÑåÌä∏ Ï∂îÍ∞Ä
interface ErrorBoundaryProps {
  children: ReactNode;
  fallback: ReactNode;
  onError?: () => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('NetworkGraph Ïò§Î•ò:', error, errorInfo);
    if (this.props.onError) {
      this.props.onError();
    }
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }
}

export default function NetworkPage({ loaderData }: Route.ComponentProps) {
  const { nodes, edges, stats, agentId } = loaderData;

  const graphRef = useRef<any>(null);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [filterSettings, setFilterSettings] = useState<NetworkFilters>({
    stageFilter: 'all',
    depthFilter: 'all',
    importanceFilter: 0,
    showInfluencersOnly: false,
  });
  const [searchQuery, setSearchQuery] = useState('');

  // üîç ÎîîÎ≤ÑÍπÖÏö©: Î†àÏù¥ÏïÑÏõÉ ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    // üéØ HTMLÍ≥º body ÏöîÏÜåÏùò Ïä§ÌÅ¨Î°§ Í∞ïÏ†ú Î∞©ÏßÄ
    const originalHTMLOverflow = document.documentElement.style.overflow;
    const originalBodyOverflow = document.body.style.overflow;
    const originalHTMLHeight = document.documentElement.style.height;
    const originalBodyHeight = document.body.style.height;

    // CSS Í∞ïÏ†ú Ï†ÅÏö©
    document.documentElement.style.setProperty(
      'overflow',
      'hidden',
      'important'
    );
    document.body.style.setProperty('overflow', 'hidden', 'important');
    document.documentElement.style.setProperty('height', '100vh', 'important');
    document.body.style.setProperty('height', '100vh', 'important');

    // Î™®Îì† Î∂ÄÎ™® Ïª®ÌÖåÏù¥ÎÑàÎì§ÎèÑ Í∞ïÏ†ú Ï†úÏñ¥
    const mainElement = document.querySelector('main');
    if (mainElement) {
      (mainElement as HTMLElement).style.setProperty(
        'overflow',
        'hidden',
        'important'
      );
      (mainElement as HTMLElement).style.setProperty(
        'height',
        'calc(100vh - 4rem)',
        'important'
      );
    }

    const checkLayout = () => {
      const body = document.body;
      const html = document.documentElement;
      const mainLayout = document.querySelector('main');
      const mainContainer = document.querySelector('[data-network-main]');
      const filterArea = document.querySelector('[data-filter-area]');
      const graphArea = document.querySelector('[data-graph-area]');
      const sidebarArea = document.querySelector('[data-sidebar-area]');

      // Card Í¥ÄÎ†® ÏöîÏÜåÎì§ Ï≤¥ÌÅ¨
      const card = document.querySelector('.graph-card');
      const cardHeader = document.querySelector('.graph-card-header');
      const cardContent = document.querySelector('.graph-card-content');

      // üéØ Ïã§Ï†ú Ïä§ÌÅ¨Î°§ Í∞ÄÎä• ÏöîÏÜå Ï∞æÍ∏∞
      const getAllScrollableElements = () => {
        const allElements = document.querySelectorAll('*');
        const scrollableElements: Array<{ element: Element; info: any }> = [];

        allElements.forEach((element) => {
          const computedStyle = getComputedStyle(element);
          const hasVerticalScroll = element.scrollHeight > element.clientHeight;
          const hasHorizontalScroll = element.scrollWidth > element.clientWidth;

          if (hasVerticalScroll || hasHorizontalScroll) {
            scrollableElements.push({
              element,
              info: {
                tagName: element.tagName,
                className: element.className,
                id: element.id,
                scrollHeight: element.scrollHeight,
                clientHeight: element.clientHeight,
                scrollWidth: element.scrollWidth,
                clientWidth: element.clientWidth,
                overflowY: computedStyle.overflowY,
                overflowX: computedStyle.overflowX,
                hasVerticalScroll,
                hasHorizontalScroll,
              },
            });
          }
        });

        return scrollableElements;
      };

      console.log('üéØ Î†àÏù¥ÏïÑÏõÉ ÏÉÅÌÉú Ï≤¥ÌÅ¨:', {
        viewportHeight: window.innerHeight,
        html: {
          hasScroll: html.scrollHeight > html.clientHeight,
          scrollHeight: html.scrollHeight,
          clientHeight: html.clientHeight,
          overflow: getComputedStyle(html).overflow,
        },
        body: {
          hasScroll: body.scrollHeight > body.clientHeight,
          scrollHeight: body.scrollHeight,
          clientHeight: body.clientHeight,
          overflow: getComputedStyle(body).overflow,
        },
        mainLayout: mainLayout
          ? {
              hasScroll: mainLayout.scrollHeight > mainLayout.clientHeight,
              scrollHeight: mainLayout.scrollHeight,
              clientHeight: mainLayout.clientHeight,
              overflow: getComputedStyle(mainLayout).overflow,
            }
          : 'not found',
        mainContainer: mainContainer
          ? {
              height: mainContainer.scrollHeight,
              clientHeight: mainContainer.clientHeight,
              hasScroll:
                mainContainer.scrollHeight > mainContainer.clientHeight,
              overflow: getComputedStyle(mainContainer).overflow,
            }
          : 'not found',
        graphArea: graphArea
          ? {
              height: graphArea.scrollHeight,
              clientHeight: graphArea.clientHeight,
              hasScroll: graphArea.scrollHeight > graphArea.clientHeight,
              overflow: getComputedStyle(graphArea).overflow,
            }
          : 'not found',
        card: card
          ? {
              height: card.scrollHeight,
              clientHeight: card.clientHeight,
              hasScroll: card.scrollHeight > card.clientHeight,
              overflow: getComputedStyle(card).overflow,
            }
          : 'not found',
        cardContent: cardContent
          ? {
              height: cardContent.scrollHeight,
              clientHeight: cardContent.clientHeight,
              hasScroll: cardContent.scrollHeight > cardContent.clientHeight,
              overflow: getComputedStyle(cardContent).overflow,
            }
          : 'not found',
        filterArea: filterArea
          ? {
              height: filterArea.scrollHeight,
              clientHeight: filterArea.clientHeight,
              hasScroll: filterArea.scrollHeight > filterArea.clientHeight,
            }
          : 'not found',
        sidebarArea: sidebarArea
          ? {
              height: sidebarArea.scrollHeight,
              clientHeight: sidebarArea.clientHeight,
              hasScroll: sidebarArea.scrollHeight > sidebarArea.clientHeight,
            }
          : 'not found',
        selectedNode: selectedNode,
        scrollableElements: getAllScrollableElements(),
      });
    };

    // üéØ Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä - Ïñ¥Îäê ÏöîÏÜåÏóêÏÑú Ïä§ÌÅ¨Î°§Ïù¥ Î∞úÏÉùÌïòÎäîÏßÄ Ï∂îÏ†Å
    const handleScroll = (event: Event) => {
      const target = event.target as Element | Document;
      const currentTarget = event.currentTarget as Element | Document;

      // document Ïä§ÌÅ¨Î°§ÏùÄ Î¨¥Ïãú (Î≤ÑÎ∏îÎßÅÎêú Ïù¥Î≤§Ìä∏)
      if (target === document) return;

      console.log('üö® Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î∞úÏÉù:', {
        target: {
          tagName: (target as Element).tagName,
          className: (target as Element).className,
          id: (target as Element).id,
        },
        currentTarget:
          currentTarget && currentTarget !== document
            ? {
                tagName: (currentTarget as Element).tagName,
                className: (currentTarget as Element).className,
                id: (currentTarget as Element).id,
              }
            : 'document',
        scrollTop: (target as Element).scrollTop,
        scrollLeft: (target as Element).scrollLeft,
        scrollHeight: (target as Element).scrollHeight,
        clientHeight: (target as Element).clientHeight,
        phase:
          event.eventPhase === 1
            ? 'capturing'
            : event.eventPhase === 2
            ? 'target'
            : 'bubbling',
        bubbles: event.bubbles,
        event: event,
      });
    };

    // üîç ÌäπÏ†ï ÏöîÏÜåÎì§Ïóê Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
    const addSpecificScrollListeners = () => {
      const elementsToWatch = [
        document.querySelector('main'),
        document.querySelector('[data-network-main]'),
        document.querySelector('[data-filter-area]'),
        document.querySelector('[data-graph-area]'),
        document.querySelector('[data-sidebar-area]'),
        document.querySelector('.graph-card'),
        document.querySelector('.graph-card-content'),
        document.body,
        document.documentElement,
      ].filter(Boolean) as Element[];

      const listeners: Array<{
        element: Element;
        listener: (e: Event) => void;
      }> = [];

      elementsToWatch.forEach((element) => {
        const listener = (e: Event) => {
          console.log(
            `üéØ ${element.tagName}.${
              element.className || 'no-class'
            }ÏóêÏÑú Ïä§ÌÅ¨Î°§:`,
            {
              scrollTop: element.scrollTop,
              scrollHeight: element.scrollHeight,
              clientHeight: element.clientHeight,
              hasScroll: element.scrollHeight > element.clientHeight,
            }
          );
        };

        element.addEventListener('scroll', listener);
        listeners.push({ element, listener });
      });

      return listeners;
    };

    // Î™®Îì† ÏöîÏÜåÏóê Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä (Ï∫°Ï≤òÎßÅÍ≥º Î≤ÑÎ∏îÎßÅ Îëò Îã§)
    document.addEventListener('scroll', handleScroll, true); // Ï∫°Ï≤òÎßÅ
    document.addEventListener('scroll', handleScroll, false); // Î≤ÑÎ∏îÎßÅ

    const specificListeners = addSpecificScrollListeners();

    // Ï¥àÍ∏∞ Ï≤¥ÌÅ¨
    setTimeout(checkLayout, 100);

    // ÏÇ¨Ïù¥ÎìúÎ∞î ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ï≤¥ÌÅ¨
    setTimeout(checkLayout, 500);

    // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú Ï≤¥ÌÅ¨
    window.addEventListener('resize', checkLayout);

    return () => {
      window.removeEventListener('resize', checkLayout);
      document.removeEventListener('scroll', handleScroll, true);
      document.removeEventListener('scroll', handleScroll, false);
      specificListeners.forEach(({ element, listener }) => {
        element.removeEventListener('scroll', listener);
      });
      document.documentElement.style.overflow = originalHTMLOverflow;
      document.body.style.overflow = originalBodyOverflow;
      document.documentElement.style.height = originalHTMLHeight;
      document.body.style.height = originalBodyHeight;

      const mainElement = document.querySelector('main');
      if (mainElement) {
        (mainElement as HTMLElement).style.removeProperty('overflow');
        (mainElement as HTMLElement).style.removeProperty('height');
      }
    };
  }, [selectedNode]);

  // Í≤ÄÏÉâ Í≤∞Í≥º ÏÉÅÌÉú Ï∂îÍ∞Ä (ÏòµÏãúÎîîÏñ∏ Ïä§ÌÉÄÏùº)
  const [searchResults, setSearchResults] = useState<
    Array<{
      id: string;
      name: string;
      type: string;
      stage?: string;
      importance?: number;
    }>
  >([]);

  // Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö© - useMemoÎ°ú ÏµúÏ†ÅÌôî
  const networkData = useMemo(
    () => ({
      nodes: nodes.map((node) => ({
        id: node.id,
        name: node.name,
        group: node.type === 'agent' ? 'influencer' : 'client',
        importance:
          node.importance === 'high' ? 5 : node.importance === 'medium' ? 3 : 1,
        stage: node.status === 'active' ? 'Í≥ÑÏïΩ ÏôÑÎ£å' : 'Ï≤´ ÏÉÅÎã¥',
      })),
      links: edges.map((edge) => ({
        source: edge.source,
        target: edge.target,
        value: edge.strength,
      })),
    }),
    [nodes, edges]
  );

  // ÏóêÎü¨ ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [graphLoadError, setGraphLoadError] = useState(false);

  // Í∑∏ÎûòÌîÑ Ïª¥Ìè¨ÎÑåÌä∏ ÎèôÏ†Å Î°úÎî© ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [NetworkGraphComponent, setNetworkGraphComponent] = useState<any>(null);

  // Î∏åÎùºÏö∞Ï†Ä ÌôòÍ≤Ω ÌôïÏù∏
  const isBrowser = typeof window !== 'undefined';

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎèôÏ†Å Î°úÎìú (dynamic import Î∞©ÏãùÏúºÎ°ú Î≥ÄÍ≤Ω)
  useEffect(() => {
    if (isBrowser && !NetworkGraphComponent) {
      // ÎèôÏ†Å import ÏÇ¨Ïö© (Î∏åÎùºÏö∞Ï†Ä ÌôòÍ≤ΩÏóêÏÑú ÏûëÎèô)
      import('../components/NetworkGraphClient')
        .then((module) => {
          setNetworkGraphComponent(() => module.default);
        })
        .catch((err) => {
          console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ Î°úÎî© Ïã§Ìå®:', err);
          setGraphLoadError(true);
        });
    }
  }, [isBrowser, NetworkGraphComponent]);

  // Ïò§Î•ò Ï≤òÎ¶¨ Ìï®Ïàò
  const handleError = useCallback(() => {
    console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ Ïò§Î•ò Î∞úÏÉù');
    setGraphLoadError(true);
  }, []);

  // Í≤ÄÏÉâ Ï≤òÎ¶¨ Ìï®Ïàò (ÏòµÏãúÎîîÏñ∏ Ïä§ÌÉÄÏùº Ï¶âÏãú Í≤ÄÏÉâ)
  const handleSearch = useCallback(
    (query: string) => {
      setSearchQuery(query);

      if (!query.trim()) {
        setSearchResults([]);
        return;
      }

      // Ïã§ÏãúÍ∞Ñ Í≤ÄÏÉâ - ÎÖ∏Îìú Ïù¥Î¶ÑÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ
      const results = nodes
        .filter((node) => node.name.toLowerCase().includes(query.toLowerCase()))
        .map((node) => ({
          id: node.id,
          name: node.name,
          type: node.type === 'agent' ? 'influencer' : 'client',
          stage: node.status === 'active' ? 'Í≥ÑÏïΩ ÏôÑÎ£å' : 'Ï≤´ ÏÉÅÎã¥',
          importance:
            node.importance === 'high'
              ? 5
              : node.importance === 'medium'
              ? 3
              : 1,
        }))
        .slice(0, 10); // ÏµúÎåÄ 10Í∞ú Í≤∞Í≥º

      setSearchResults(results);
    },
    [nodes]
  );

  // ÎÖ∏Îìú Ìè¨Ïª§Ïä§ Ìï®Ïàò (ÏòµÏãúÎîîÏñ∏ Ïä§ÌÉÄÏùº)
  const handleNodeFocus = useCallback(
    (nodeId: string) => {
      setSelectedNode(nodeId);

      // Í∑∏ÎûòÌîÑÏóêÏÑú Ìï¥Îãπ ÎÖ∏ÎìúÎ°ú Ïù¥Îèô
      if (graphRef.current && typeof graphRef.current.centerAt === 'function') {
        const node = nodes.find((n) => n.id === nodeId);
        if (node && node.position) {
          // ÎÖ∏Îìú ÏúÑÏπòÎ°ú Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô
          graphRef.current.centerAt(node.position.x, node.position.y, 1000);
        }
      }
    },
    [nodes]
  );

  const handleNodeSelect = useCallback((nodeId: string) => {
    setSelectedNode(nodeId);
  }, []);

  // ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞ Ìï®Ïàò - useMemoÎ°ú ÏµúÏ†ÅÌôî
  const filteredData = useMemo(() => {
    // ÎÖ∏Îìú ÌïÑÌÑ∞ÎßÅ Î°úÏßÅ
    let filteredNodes = [...networkData.nodes];

    // ÏòÅÏóÖ Îã®Í≥ÑÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
    if (filterSettings.stageFilter !== 'all') {
      filteredNodes = filteredNodes.filter(
        (node) => node.stage === filterSettings.stageFilter
      );
    }

    // Ï§ëÏöîÎèÑ Í∏∞Ï§Ä ÌïÑÌÑ∞ÎßÅ
    if (filterSettings.importanceFilter > 0) {
      filteredNodes = filteredNodes.filter(
        (node) => (node.importance || 0) >= filterSettings.importanceFilter
      );
    }

    // ÌïµÏã¨ ÏÜåÍ∞úÏûê ÌïÑÌÑ∞ÎßÅ
    if (filterSettings.showInfluencersOnly) {
      const influencersAndConnections = new Set<string>();

      // Ïö∞ÏÑ† Î™®Îì† ÏòÅÌñ•Î†• ÏûàÎäî ÏÇ¨Ïö©Ïûê(influencer) ÏãùÎ≥Ñ
      const influencers = networkData.nodes.filter(
        (node) => node.group === 'influencer'
      );
      influencers.forEach((influencer) =>
        influencersAndConnections.add(influencer.id)
      );

      // Í∞Å ÏòÅÌñ•Î†• ÏûàÎäî ÏÇ¨Ïö©ÏûêÏôÄ ÏßÅÏ†ë Ïó∞Í≤∞Îêú Î™®Îì† ÎÖ∏ÎìúÎ•º Ï∂îÍ∞Ä
      networkData.links.forEach((link: NetworkLink) => {
        const sourceId =
          typeof link.source === 'string' ? link.source : link.source.id;
        const targetId =
          typeof link.target === 'string' ? link.target : link.target.id;

        // ÏÜåÏä§Í∞Ä influencerÏù∏ Í≤ΩÏö∞ ÌÉÄÍ≤ü ÎÖ∏Îìú Ï∂îÍ∞Ä
        if (influencers.some((inf) => inf.id === sourceId)) {
          influencersAndConnections.add(targetId);
        }

        // ÌÉÄÍ≤üÏù¥ influencerÏù∏ Í≤ΩÏö∞ ÏÜåÏä§ ÎÖ∏Îìú Ï∂îÍ∞Ä
        if (influencers.some((inf) => inf.id === targetId)) {
          influencersAndConnections.add(sourceId);
        }
      });

      // ÌïµÏã¨ ÏÜåÍ∞úÏûêÏôÄ Í∑∏Îì§Ïùò Ïó∞Í≤∞ ÎÖ∏ÎìúÎßå ÎÇ®ÍπÄ
      filteredNodes = filteredNodes.filter((node) =>
        influencersAndConnections.has(node.id)
      );
    }

    // ÏÜåÍ∞ú ÍπäÏù¥Ïóê Îî∞Î•∏ ÌïÑÌÑ∞ÎßÅ
    if (filterSettings.depthFilter !== 'all') {
      // ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÎßÅÌÅ¨ Ï†ïÎ≥¥ Ï∂îÏ∂ú
      const nodeConnections = new Map();

      // Î™®Îì† ÏßÅÏ†ë Ïó∞Í≤∞ Í¥ÄÍ≥Ñ ÏàòÏßë
      networkData.links.forEach((link: NetworkLink) => {
        const sourceId =
          typeof link.source === 'string' ? link.source : link.source.id;
        const targetId =
          typeof link.target === 'string' ? link.target : link.target.id;

        if (!nodeConnections.has(sourceId)) {
          nodeConnections.set(sourceId, new Set());
        }
        nodeConnections.get(sourceId).add(targetId);
      });

      if (filterSettings.depthFilter === 'direct') {
        // ÏßÅÏ†ë ÏÜåÍ∞úÎßå ÌëúÏãú (1Ï¥å)
        const directConnectionNodes = new Set();

        // ÏòÅÌñ•Î†• ÏûàÎäî ÏÇ¨Ïö©Ïûê(influencer)ÏôÄ Í∑∏Îì§Ïùò ÏßÅÏ†ë Ïó∞Í≤∞ ÎÖ∏ÎìúÎßå ÏÑ†ÌÉù
        filteredNodes.forEach((node) => {
          if (node.group === 'influencer') {
            directConnectionNodes.add(node.id);
            const connections = nodeConnections.get(node.id);
            if (connections) {
              connections.forEach((targetId: string) => {
                directConnectionNodes.add(targetId);
              });
            }
          }
        });

        filteredNodes = filteredNodes.filter((node) =>
          directConnectionNodes.has(node.id)
        );
      }
    }

    // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞ÎßÅ (Í≤ÄÏÉâÏñ¥Í∞Ä ÏûàÎäî Í≤ΩÏö∞)
    if (searchQuery.trim()) {
      const lowerQuery = searchQuery.toLowerCase().trim();
      filteredNodes = filteredNodes.filter((node) =>
        node.name.toLowerCase().includes(lowerQuery)
      );
    }

    // ÌïÑÌÑ∞ÎßÅÎêú ÎÖ∏ÎìúID Î™©Î°ù
    const filteredNodeIds = new Set(filteredNodes.map((node) => node.id));

    // ÎßÅÌÅ¨ ÌïÑÌÑ∞ÎßÅ (ÏñëÏ™Ω ÎÖ∏ÎìúÍ∞Ä Î™®Îëê ÌïÑÌÑ∞ÎßÅÎêú Í≤∞Í≥ºÏóê ÏûàÎäî Í≤ΩÏö∞Îßå Ìè¨Ìï®)
    const filteredLinks = networkData.links.filter((link: NetworkLink) => {
      const sourceId =
        typeof link.source === 'string' ? link.source : link.source.id;
      const targetId =
        typeof link.target === 'string' ? link.target : link.target.id;
      return filteredNodeIds.has(sourceId) && filteredNodeIds.has(targetId);
    });

    return {
      nodes: filteredNodes,
      links: filteredLinks,
    };
  }, [networkData, filterSettings, searchQuery]);

  // ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ ÏÉÅÌÉú - useMemoÎ°ú ÏµúÏ†ÅÌôî
  const networkStats = useMemo(
    () => ({
      totalNodes: networkData.nodes.length,
      filteredNodes: filteredData.nodes.length,
      influencerCount: filteredData.nodes.filter(
        (n) => n.group === 'influencer'
      ).length,
      connectionCount: filteredData.links.length,
    }),
    [networkData.nodes.length, filteredData.nodes, filteredData.links.length]
  );

  // ÌïÑÌÑ∞ Î≥ÄÍ≤Ω Ïãú ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
  const handleFilterChange = useCallback((newFilters: NetworkFilters) => {
    setFilterSettings(newFilters);
  }, []);

  // Í∑∏ÎûòÌîÑ Ïª¥Ìè¨ÎÑåÌä∏ Î†åÎçîÎßÅ
  const renderNetworkGraph = () => {
    // ÏÑúÎ≤Ñ Î†åÎçîÎßÅ Ïãú ÌëúÏãúÌï† ÎÇ¥Ïö©
    if (typeof window === 'undefined') {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="text-center">
            <p className="mb-2">Í∑∏ÎûòÌîÑ Î°úÎî© Ï§ë...</p>
            <div className="animate-spin w-6 h-6 border-2 border-primary border-t-transparent rounded-full mx-auto"></div>
          </div>
        </div>
      );
    }

    // ÏóêÎü¨ ÏÉÅÌÉúÏùº Îïå ÌëúÏãúÌï† ÎÇ¥Ïö©
    if (graphLoadError) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="text-center max-w-md p-4">
            <p className="text-red-500 mb-4">
              Í∑∏ÎûòÌîÑÎ•º Î°úÎìúÌïòÎäîÎç∞ Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
            </p>
            <button
              className="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors"
              onClick={() => window.location.reload()}
            >
              ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®
            </button>
          </div>
        </div>
      );
    }

    // Ïª¥Ìè¨ÎÑåÌä∏ Î°úÎî© Ï§ëÏùº Îïå ÌëúÏãúÌï† ÎÇ¥Ïö©
    if (!NetworkGraphComponent) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="text-center">
            <p className="mb-2">Í∑∏ÎûòÌîÑ Î°úÎî© Ï§ë...</p>
            <div className="animate-spin w-6 h-6 border-2 border-primary border-t-transparent rounded-full mx-auto"></div>
          </div>
        </div>
      );
    }

    // NetworkGraphComponentÍ∞Ä Î°úÎìúÎêòÏóàÏùÑ Îïå Î†åÎçîÎßÅ
    return (
      <ErrorBoundary
        fallback={
          <div className="flex items-center justify-center h-full">
            <div className="text-center max-w-md p-4">
              <p className="text-red-500 mb-4">
                Í∑∏ÎûòÌîÑ Î†åÎçîÎßÅ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.
              </p>
              <button
                className="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors"
                onClick={() => window.location.reload()}
              >
                ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®
              </button>
            </div>
          </div>
        }
        onError={handleError}
      >
        <NetworkGraphComponent
          data={networkData}
          onNodeSelect={handleNodeSelect}
          filters={filterSettings}
          searchQuery={searchQuery}
          graphRef={graphRef}
          highlightedNodeId={selectedNode}
        />
      </ErrorBoundary>
    );
  };

  return (
    <MainLayout title="ÏÜåÍ∞ú ÎÑ§Ìä∏ÏõåÌÅ¨">
      <div
        data-network-main
        className={`grid gap-2 ${
          selectedNode
            ? 'grid-cols-1 lg:grid-cols-9' // ÎÖ∏Îìú ÏÑ†ÌÉù Ïãú: ÌïÑÌÑ∞2 + Í∑∏ÎûòÌîÑ5 + ÏÉÅÏÑ∏2
            : 'grid-cols-1 lg:grid-cols-7' // ÎÖ∏Îìú ÎØ∏ÏÑ†ÌÉù Ïãú: ÌïÑÌÑ∞2 + Í∑∏ÎûòÌîÑ5
        }`}
        style={{
          height: 'calc(100vh - 4rem)',
          maxHeight: 'calc(100vh - 4rem)',
          overflow: 'hidden',
          padding: '0.75rem', // Ï†ÅÏ†àÌïú padding
        }}
      >
        {/* ÌïÑÌÑ∞ ÏÇ¨Ïù¥ÎìúÎ∞î - ÏÑ∏Î°ú Í∏∏Ïù¥ Í≥†Ï†ï, ÎÇ¥Ïö© Í∏∏Ïñ¥ÏßÄÎ©¥ Í∞úÎ≥Ñ Ïä§ÌÅ¨Î°§ */}
        <div
          data-filter-area
          className="lg:col-span-2"
          style={{
            height: 'calc(100vh - 5.5rem)',
            maxHeight: 'calc(100vh - 5.5rem)',
            overflow: 'hidden',
          }}
        >
          <NetworkSidebar
            filters={filterSettings}
            onFilterChange={handleFilterChange}
            stats={networkStats}
          />
        </div>

        {/* Î©îÏù∏ ÏΩòÌÖêÏ∏† ÏòÅÏó≠ - Í∑∏ÎûòÌîÑÎ∑∞ Í≥†Ï†ï, ÏÑ∏Î°ú Í∏∏Ïù¥ Í≥†Ï†ï */}
        <div
          data-graph-area
          className="lg:col-span-5"
          style={{
            height: 'calc(100vh - 5.5rem)',
            maxHeight: 'calc(100vh - 5.5rem)',
            overflow: 'hidden',
          }}
        >
          <Card
            className="h-full flex flex-col graph-card"
            style={{ overflow: 'hidden', height: '100%' }}
          >
            <CardHeader className="flex-shrink-0 pb-2 px-4 pt-3 graph-card-header">
              <CardTitle className="text-lg">ÏÜåÍ∞ú ÎÑ§Ìä∏ÏõåÌÅ¨</CardTitle>
              <CardDescription className="text-sm">
                Í≥†Í∞ù Í∞Ñ ÏÜåÍ∞ú Í¥ÄÍ≥ÑÎ•º ÏãúÍ∞ÅÌôîÌï©ÎãàÎã§. ÎÖ∏ÎìúÎ•º ÌÅ¥Î¶≠ÌïòÎ©¥ ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Î≥º
                Ïàò ÏûàÏäµÎãàÎã§.
              </CardDescription>

              {/* Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
              <div className="pt-2">
                <NetworkControls
                  onSearch={handleSearch}
                  searchResults={searchResults}
                  onNodeFocus={handleNodeFocus}
                />
              </div>
            </CardHeader>

            <CardContent
              className="flex-1 p-0 overflow-hidden graph-card-content"
              style={{ overflow: 'hidden', height: '100%' }}
            >
              {/* Í∑∏ÎûòÌîÑ ÏãúÍ∞ÅÌôî - Î∏åÎùºÏö∞Ï†Ä ÎÜíÏù¥Ïóê ÎßûÏ∂∞ Í≥†Ï†ï, Ïä§ÌÅ¨Î°§ ÏóÜÏùå */}
              <div
                className="w-full h-full relative"
                style={{ overflow: 'hidden' }}
              >
                {renderNetworkGraph()}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Í≥†Í∞ù ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ìå®ÎÑê - ÏÑ∏Î°ú Í∏∏Ïù¥ Í≥†Ï†ï, ÎÇ¥Ïö© Í∏∏Ïñ¥ÏßÄÎ©¥ Í∞úÎ≥Ñ Ïä§ÌÅ¨Î°§ */}
        {selectedNode && (
          <div
            data-sidebar-area
            className="lg:col-span-2"
            style={{
              height: 'calc(100vh - 5.5rem)',
              maxHeight: 'calc(100vh - 5.5rem)',
              overflow: 'hidden',
            }}
          >
            <NetworkDetailPanel
              nodeId={selectedNode}
              data={networkData}
              onClose={() => setSelectedNode(null)}
              onNodeSelect={handleNodeSelect}
            />
          </div>
        )}
      </div>
    </MainLayout>
  );
}
